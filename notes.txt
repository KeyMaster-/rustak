# Structure
x need a utility parsing function file to include in parse.rs and in tests.rs
x Allow StoneStack to be empty, get rid of boardspace etc as a result.
  Try this on a branch, see if it actually improves code structure.
x Better error types in test parsing functions.
  Need to handle nom errors (with input location context and custom context strings)
  as well as object construction errors.
    Need to understand how the add context & combine error functions work.
    I think as a parse tree fails upwards, it accumulates errors.
  Outcome: 
    Nom 5's map_res discards the map's error and replaces it with a simple "MapRes" error kind.
    This means that the construction errors get entirely discarded.
    To get around this, moved to the nom 6 alpha, which includes changes to propagate the map_res error.
      This also added a `finish()` method which converts IResult to Result. This is close to but not quite
      what I do with finalise (it doesn't convert (Remaining, Output) to just Output). Might be worth suggesting
      on the nom repo in the future?
    Copied Amos' custom error type (which largely compies VerboseError) for error accumulating and some formatting.
    Added the FromExternalError trait to accept generic construction errors.
    Included thiserror to make all of lib's errors into std::error::Errors since that's what FromExternalError wants.
  
. Add error context to appropriate places in the test parsers.
x Better error types for game types (see todos)
  Outcome: All the relevant actions only failed due to a single reason now, so adding an error type seems unnecessary.
x Add bounded integer crate and use it for size and position values
  This should remove some range checks at construction time, e.g. for board size.
  This won't get around checking location-in-board cases, I don't want to tie the location type to board size.
  Outcome: 
    This did indeed remove a bunch of checks and Option<Self> returns, happy with it.
    Did require patching bounded-integer though, since it added ops for unsigned types even though the underlying type does not support those ops.
    Namely saturating neg and all variations of abs.

. Maybe separate out the binary and library of this, since the binary has a few dependencies that the library doesn't need.
. Remove vendored bounded integer library
. Move board into its own module
  This makes things more organised, and also enforces using the board's 
  public interface for manipulating it.

# Move builder
- make move builder separate object, or part of the game?
  move builder needs access to board and stones. turn and state is technically only needed when committing a move.
  when we commit a move, we already have the changed board&pieces state. if separate, need to copy back.
  with granular undo, don't need to keep a copy of the old state.
  Make it part of the game object I think.

- now that move logic moves outside of the board struct, need to provide additional accessors to mutate it.
  get mutable stone stack at location, mainly
  Turned out that I didn't need this - since everything is in the same module atm all the code has access to all the struct internals

. Action undo

## Cleanup
. Clean out board's make_move and related unused types/functions
. Clean up commented-out old code (e.g. old game make_move)
. Sort out the ActionInvalidReason / MoveInvalidReason difference
  Some errors don't make sense for move - keep having separate types + panic on implementation errors?
. Be consistent about variable naming (loc vs location) and order (loc/kind in MoveState, kind/loc in Move::Placement)
. Be consistent about taking copy-able types by ref or by value (e.g. loc, dir, etc)

# Rules
x implement carry limit
x win checking
  return continue/colour win as Ok result from make_move
  x road
  x space cover
  x run out of pieces

# Testing
. hand-written tests
  x parse game state from string
    reconstruct number of pieces left etc based on pieces placed

. Parsing tests
  . Add "root cause" method to error type (?)
    The full error type is hard to assert against, and we don't care about the exact chain of parsers that got us there.
    What we care about is that it reports the correct validation error if there is one (e.g. invalid game size, invalid stack),
    or potentially also the input position it failed at.

## Positive testing from playtak history
. create test data processing binary
  . Extract games data from playtak database
  . parse & convert to game history struct (game size + list of moves + end result)
    . this will need a game constructor for different sizes, unless I filter out anything not 5x5
    . I can ignore end result for now
  . serialize to file

. create test harness
  . deserialize test histories from file
  . Run through, verify that no move is ever invalid

. fuzz testing (?)
  . load test histories, randomly mutate moves
    Issues: Can't know easily what error to expect.
            Also might happen to mutate to another valid move.

---
# Tests to add

First round
  x Place non-flat on first round
  x swaps colours

Placement
  . Place into non-empty space

Movement
  Pickup
    . Pick up more than in stack
    . Move above carry limit

  Drops
    . Move on top of standing stone without flattening (flat, other standing)
    . Move on top of standing stone with flattening (capstone onto standing)
    . Move on top of capstone

  Locations
    . Start move outside board
    . Move out of board

Move actions
  . // TODO