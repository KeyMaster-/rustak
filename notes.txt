experiment with doing either of these two patterns:
1.
  if !next_step_valid { return }
  do_next_step()

  where do_next_step will panic if next_step_valid was false

2. 
  do_next_step().ok_or(Error)?

  where do_next_step returns a value if the operation is valid, and None if not


Examples this applies for so far:
  StoneStack.take_stones

  Grid[location]
    Probably should be Grid.get(location) then, which will need a newtype over grid

--
# Structure
x need a utility parsing function file to include in parse.rs and in tests.rs
x Allow StoneStack to be empty, get rid of boardspace etc as a result.
  Try this on a branch, see if it actually improves code structure.
x Better error types in test parsing functions.
  Need to handle nom errors (with input location context and custom context strings)
  as well as object construction errors.
    Need to understand how the add context & combine error functions work.
    I think as a parse tree fails upwards, it accumulates errors.
  Outcome: 
    Nom 5's map_res discards the map's error and replaces it with a simple "MapRes" error kind.
    This means that the construction errors get entirely discarded.
    To get around this, moved to the nom 6 alpha, which includes changes to propagate the map_res error.
      This also added a `finish()` method which converts IResult to Result. This is close to but not quite
      what I do with finalise (it doesn't convert (Remaining, Output) to just Output). Might be worth suggesting
      on the nom repo in the future?
    Copied Amos' custom error type (which largely compies VerboseError) for error accumulating and some formatting.
    Added the FromExternalError trait to accept generic construction errors.
    Included thiserror to make all of lib's errors into std::error::Errors since that's what FromExternalError wants.
  
. Add error context to appropriate places in the test parsers.
. Better error types for game types (see todos)
. Add bounded integer crate and use it for size and position values
  This should remove some range checks at construction time, e.g. for board size.
  This won't get around checking location-in-board cases, I don't want to tie the location type to board size.

# Rules
x implement carry limit
. win checking
  return continue/colour win as Ok result from make_move
  . road
  . space cover
  . run out of pieces

# Testing
. hand-written tests
  x parse game state from string
    reconstruct number of pieces left etc based on pieces placed

. Parsing tests
  . Add "root cause" method to error type (?)
    The full error type is hard to assert against, and we don't care about the exact chain of parsers that got us there.
    What we care about is that it reports the correct validation error if there is one (e.g. invalid game size, invalid stack),
    or potentially also the input position it failed at.

## Positive testing from playtak history
. create test data processing binary
  . Extract games data from playtak database
  . parse & convert to game history struct (game size + list of moves + end result)
    . this will need a game constructor for different sizes, unless I filter out anything not 5x5
    . I can ignore end result for now
  . serialize to file

. create test harness
  . deserialize test histories from file
  . Run through, verify that no move is ever invalid

. fuzz testing (?)
  . load test histories, randomly mutate moves
    Issues: Can't know easily what error to expect.
            Also might happen to mutate to another valid move.

---
# Tests to add

First round
  . Place non-flat on first round
  . Move on first round

Placement
  . Place into non-empty space

Movement
  Pickup
    . Pick up more than in stack
    . Move above carry limit

  Drops
    . Move on top of standing stone without flattening (flat, other standing)
    . Move on top of standing stone with flattening (capstone onto standing)
    . Move on top of capstone

  Locations
    . Start move outside board
    . Move out of board
